<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta name="theme-color" content="#140b22">
  <title>Calendar Game</title>
  <meta name="application-name" content="Calendar Game">
  <meta name="apple-mobile-web-app-title" content="Calendar Game">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{--bg1:#0b0714;--bg2:#140b22}
    body{background:linear-gradient(180deg,var(--bg1),var(--bg2))}
    .card{background:rgba(26,15,43,.85);border:1px solid rgba(120,53,175,.45)}
    .panel{background:rgba(88,28,135,.25);border:1px solid rgba(120,53,175,.45)}
    .thin{border:1px solid rgba(120,53,175,.35)}
    button,input,select{-webkit-tap-highlight-color:transparent}
    button{touch-action:manipulation}
    @keyframes flashPulse{0%{box-shadow:0 0 0 0 var(--ring);background:var(--bg0)}
      35%{box-shadow:0 0 0 10px var(--ring);background:var(--bg1)}
      100%{box-shadow:0 0 0 0 transparent;background:var(--bg0)}}
    .flash-good{--ring:rgba(16,185,129,.5);--bg0:rgba(16,185,129,.5);--bg1:rgba(16,185,129,.5);animation:flashPulse .45s ease-in-out}
    .flash-bad{--ring:rgba(239,68,68,.5);--bg0:rgba(239,68,68,.5);--bg1:rgba(239,68,68,.5);animation:flashPulse .45s ease-in-out}
    .chip{background:rgba(120,53,175,.25);border:1px solid rgba(120,53,175,.45);padding:.25rem .5rem;border-radius:.75rem;font-size:12px}
    .bar{height:6px;border-radius:6px;overflow:hidden;background:rgba(120,53,175,.25);border:1px solid rgba(120,53,175,.45)}
    .bar>span{display:block;height:100%;background:linear-gradient(90deg,#a855f7,#7c3aed)}
    .expander{transition:max-height .25s ease-in-out;overflow:hidden;will-change:max-height}
  </style>
</head>
<body class="text-purple-50">
  <div id="root" class="min-h-screen w-full">Loading…</div>
  <pre id="errors" style="display:none;white-space:pre-wrap;background:#2b0f3a;border:1px solid #7e22ce;color:#fca5a5;padding:.75rem;border-radius:.75rem;margin:1rem;max-width:64rem"></pre>

  <script>
    const __errBox = () => document.getElementById('errors');
    const __hideErr = () => { const x=__errBox(); if(x){ x.style.display='none'; x.textContent=''; } };
    addEventListener('error', e=>{
      const x=__errBox(); if(!x) return;
      x.style.display='block';
      const loc = e.filename? `\n at ${e.filename}:${e.lineno}:${e.colno}` : '';
      x.textContent = `⚠️ ${e.message||String(e)}${loc}\n${e.error?.stack||''}`;
    });
    addEventListener('unhandledrejection', e=>{
      const x=__errBox(); if(!x) return;
      x.style.display='block';
      const msg = e.reason?.message || String(e.reason);
      x.textContent = `⚠️ Promise rejection: ${msg}\n${e.reason?.stack||''}`;
    });
  </script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel" data-presets="env,react">
    const {useEffect,useMemo,useRef,useState,useId} = React;

    /* ---------- Calendar helpers ---------- */
    const MONTH=["January","February","March","April","May","June","July","August","September","October","November","December"];
    const DAY=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    const toAstro = y => y>0?y:1-Math.abs(y);
    const isLeap = y => { y=toAstro(y); return y%400===0 || (y%4===0 && y%100!==0); };
    const dim = (y,m)=> m===2 ? (isLeap(y)?29:28) : [4,6,9,11].includes(m)?30:31;
    function jdnGregorian(y,m,d){ const a=Math.floor((14-m)/12),y2=y+4800-a,m2=m-3+12*a; return d+Math.floor((153*m2+2)/5)+365*y2+Math.floor(y2/4)-Math.floor(y2/100)+Math.floor(y2/400)-32045; }
    const wday=(y,m,d)=> (jdnGregorian(toAstro(y),m,d)+1)%7;
    const fmtYear = y => y>0?String(y):`${Math.abs(y)} BC`;
    const fmt=(y,m,d)=> `${MONTH[m-1]} ${d}, ${fmtYear(y)}`;
    const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    function randomDate(minY,maxY){ for(;;){ let y=rint(minY,maxY); if(y===0) continue; let m=rint(1,12), d=rint(1,dim(y,m)); if(d<=dim(y,m)) return {y,m,d}; } }
    const blankDedTypeStore = ()=>({year:null,month:null,day:null});

    const isTouch=typeof window!=="undefined" && ("ontouchstart" in window || navigator.maxTouchPoints>0 || matchMedia("(pointer:coarse)").matches);
    const isTimer = m => m==="blitz"||m==="sudden"||m==="flash";
    const formatSecondsLabel = (seconds)=>{
      if(!Number.isFinite(seconds)) return "0s";
      const value=Math.max(0,seconds);
      if(value<=0.05) return "0s";
      return `${value.toFixed(1)}s`;
    };
    const blockMinusKey = (event)=>{
      if(event.key==="-" || event.key==="Subtract" || event.key==="Minus"){
        event.preventDefault();
      }
    };
    const blockMinusBeforeInput = (event)=>{
      if(event.data && event.data.includes("-")){
        event.preventDefault();
      }
    };

    /* ---------- atoms ---------- */
    const Stat=({label,value,disabled})=>(
      <div className={`px-3 py-2 rounded-xl panel text-center ${disabled?'opacity-60':''}`}>
        <div className="text-[12px] text-purple-200/80">{label}</div>
        <div className="text-lg font-semibold tabular-nums">{disabled?'—':value}</div>
      </div>
    );
    const StatTwo=({label,left,right,disabled})=>(
      <div className={`px-3 py-2 rounded-xl panel text-center ${disabled?'opacity-60':''}`}>
        <div className="text-[12px] text-purple-200/80">{label}</div>
        <div className="text-lg font-semibold tabular-nums">{disabled?'—':`${left}/${right}`}</div>
      </div>
    );

    /* ======================= App ======================= */
    function App(){
      const [mode,setMode]=useState("classic");
      const modeSelectRef=useRef(null);

      /* era + independent ranges (AD / BC / BOTH) */
      const [era,setEra]=useState('AD');                   // 'AD' | 'BOTH' | 'BC'
      const [adRange,setAdRange]=useState({min:1,max:10000});
      const [bcRange,setBcRange]=useState({min:-10000,max:-1});
      const [bothRange,setBothRange]=useState({min:-10000,max:10000});
      const [minY,setMinY]=useState(1), [maxY,setMaxY]=useState(10000);
      const [minInput,setMinInput]=useState('1');
      const [maxInput,setMaxInput]=useState('10000');
      const minInputId=useId();
      const maxInputId=useId();

      const [date,setDate]=useState(()=>randomDate(1,10000));
      const [stack,setStack]=useState([]), [dedStack,setDedStack]=useState([]);

      const correct=useMemo(()=>wday(date.y,date.m,date.d),[date]);
      const [guesses,setGuesses]=useState([]);                 // wrong guesses (chips)
      const [msg,setMsg]=useState("");                         // Answer: ...
      const [locked,setLocked]=useState(false);                // lock options after reveal
      const [revealed,setRevealed]=useState(false);            // did reveal on this date?
      const [countedWrong,setCountedWrong]=useState(false);    // has wrong been counted?

      /* snapshots when avg-time disabled (per era) */
      const [savedClassicByEra,setSavedClassicByEra]=useState({AD:null,BC:null,BOTH:null});
      const [savedDedByEra,setSavedDedByEra]=useState({AD:null,BC:null,BOTH:null}); /* NEW */
      const [savedDedByType,setSavedDedByType]=useState(()=>blankDedTypeStore());

      /* per-mode stats */
      const blankStats=()=>({played:0,good:0,streak:0,best:0,timeSum:0,timeCnt:0});
      const [statsByMode,setStatsByMode]=useState({classic:blankStats(), blitz:blankStats(), sudden:blankStats(), flash:blankStats(), deduction:blankStats()});
      const S = statsByMode[mode] || blankStats();

      const [statsOff,setStatsOff]=useState(false);
      const [trackClassic,setTrackClassic]=useState(false);    // avg time enabled? (classic)
      const [trackDed,setTrackDed]=useState(false);            // avg time enabled? (deduction)

      const tStartRef=useRef(null);
      const [flash,setFlash]=useState(null);

      /* timers */
      const [blitzSec,setBlitzSec]=useState(60), [blitzRemain,setBlitzRemain]=useState(60), [blitzRunning,setBlitzRunning]=useState(false);
      const blitzStartRef=useRef(null), blitzPausedAtRef=useRef(null), blitzPausedAccRef=useRef(0);
      const [qSec,setQSec]=useState(7), [qRemain,setQRemain]=useState(7);
      const qDeadlineRef=useRef(null), qPausedAtRef=useRef(null), qPausedAccRef=useRef(0);
      const [active,setActive]=useState(false);

      /* flash mode */
      const [flashMs,setFlashMs]=useState(1200);
      const [phase,setPhase]=useState('dash'); // 'dash' | 'show' | 'hide'
      const flashTimerRef=useRef(null);
      const [flashRemainMs,setFlashRemainMs]=useState(1200);
      const flashDeadlineRef=useRef(null);

      /* deduction */
      const [dedType,setDedType]=useState("year");
      const [ded,setDed]=useState(null);
      const [dedFlash,setDedFlash]=useState(null);
      const [lookupHistory,setLookupHistory]=useState([]);

      const pendingDedSwitchRef=useRef(null);

      const inputRef=useRef(null), [input,setInput]=useState("");
      useEffect(()=>{
        if(!isTouch){
          inputRef.current?.focus();
        }else{
          const active=document.activeElement;
          if(active && active!==modeSelectRef.current && active.tagName==='INPUT'){
            active.blur();
          }
        }
      },[date,mode,active]);

      /* helpers */
      const updateStats = (mutator)=>{ setStatsByMode(prev=>{ const cur={...(prev[mode]||blankStats())}; mutator(cur); return {...prev,[mode]:cur}; }); };
      const resetStatsCurrent=()=>{ setStatsByMode(prev=>({...prev,[mode]:blankStats()})); };

      /* avg-time toggle reset of sums when enabling */
      const prevTrackClassic=useRef(trackClassic);
      useEffect(()=>{ if(prevTrackClassic.current===false && trackClassic===true){ setStatsByMode(p=>({...p, classic:{...(p.classic||blankStats()), timeSum:0, timeCnt:0}})); tStartRef.current=performance.now(); } prevTrackClassic.current=trackClassic; },[trackClassic]);
      const prevTrackDed=useRef(trackDed);
      useEffect(()=>{
        if(prevTrackDed.current===false && trackDed===true){
          setStatsByMode(p=>({...p, deduction:{...(p.deduction||blankStats()), timeSum:0, timeCnt:0}}));
          tStartRef.current=performance.now();
          setSavedDedByType(blankDedTypeStore());
        }else if(prevTrackDed.current===true && trackDed===false){
          setSavedDedByType(blankDedTypeStore());
        }
        prevTrackDed.current=trackDed;
      },[trackDed]);

      /* ===== Range helpers ===== */
      const fmtRangeYear = (y)=> y>0?`${y} AD`:`${Math.abs(y)} BC`;
      const labelForYear = (y)=> y>=0?'AD':'BC';
      const displayInputValue = (y, scopeEra=era)=>{
        if(scopeEra==='BC' || scopeEra==='BOTH') return String(Math.abs(y));
        return String(y);
      };

      function applyMinValue(val){
        if(era==='AD'){ setAdRange(r=>({...r,min:val})); }
        else if(era==='BC'){ setBcRange(r=>({...r,min:val})); }
        else { setBothRange(r=>({...r,min:val})); }
        setMinY(val);
      }

      function applyMaxValue(val){
        if(era==='AD'){ setAdRange(r=>({...r,max:val})); }
        else if(era==='BC'){ setBcRange(r=>({...r,max:val})); }
        else { setBothRange(r=>({...r,max:val})); }
        setMaxY(val);
      }

      function sanitizeMinInputValue(raw, signHint=null){
        if(!Number.isFinite(raw)) return minY;
        let val=Math.trunc(raw);
        let sign=1;
        if(era==='AD'){
          val=Math.max(1, Math.min(10000, val));
          sign=1;
        }else if(era==='BC'){
          val=-Math.max(1, Math.min(10000, Math.abs(val)));
          sign=-1;
        }else{
          sign = signHint!=null ? (signHint<0?-1:1) : (minY<0?-1:1);
          const magnitude=Math.max(1, Math.min(10000, Math.abs(val)));
          val = sign<0 ? -magnitude : magnitude;
        }
        if(era!=='BOTH' && val>maxY) val=maxY;
        if(val===0) val = sign<0 ? -1 : 1;
        return val;
      }

      function sanitizeMaxInputValue(raw, signHint=null){
        if(!Number.isFinite(raw)) return maxY;
        let val=Math.trunc(raw);
        let sign=1;
        if(era==='AD'){
          val=Math.max(1, Math.min(10000, val));
          sign=1;
        }else if(era==='BC'){
          val=-Math.max(1, Math.min(10000, Math.abs(val)));
          sign=-1;
        }else{
          sign = signHint!=null ? (signHint<0?-1:1) : (maxY<0?-1:1);
          const magnitude=Math.max(1, Math.min(10000, Math.abs(val)));
          val = sign<0 ? -magnitude : magnitude;
        }
        if(era!=='BOTH' && val<minY) val=minY;
        if(val===0) val = sign<0 ? -1 : 1;
        return val;
      }

      function handleMinInputChange(str){
        setMinInput(str);
        const trimmed=str.trim();
        if(trimmed==='') return;
        if(!/^\d+$/.test(trimmed)) return;
        const parsed=Number.parseInt(trimmed,10);
        if(Number.isNaN(parsed)) return;
        const signHint = era==='BC' ? -1 : era==='BOTH' ? (minY<0?-1:1) : 1;
        const val=sanitizeMinInputValue(parsed, signHint);
        if(era==='BOTH' && val>maxY){
          applyMaxValue(val);
          setMaxInput(displayInputValue(val,'BOTH'));
        }
        applyMinValue(val);
        setMinInput(displayInputValue(val));
      }

      function handleMaxInputChange(str){
        setMaxInput(str);
        const trimmed=str.trim();
        if(trimmed==='') return;
        if(!/^\d+$/.test(trimmed)) return;
        const parsed=Number.parseInt(trimmed,10);
        if(Number.isNaN(parsed)) return;
        const signHint = era==='BC' ? -1 : era==='BOTH' ? (maxY<0?-1:1) : 1;
        const val=sanitizeMaxInputValue(parsed, signHint);
        if(era==='BOTH' && val<minY){
          applyMinValue(val);
          setMinInput(displayInputValue(val,'BOTH'));
        }
        applyMaxValue(val);
        setMaxInput(displayInputValue(val));
      }

      function toggleMinSign(){
        if(era!=='BOTH') return;
        const magnitude=Math.max(1, Math.min(10000, Math.abs(minY)||1));
        const nextSign = minY<0?1:-1;
        let val = nextSign<0 ? -magnitude : magnitude;
        if(val>maxY){
          applyMaxValue(val);
          setMaxInput(displayInputValue(val,'BOTH'));
        }
        applyMinValue(val);
        setMinInput(displayInputValue(val,'BOTH'));
      }

      function toggleMaxSign(){
        if(era!=='BOTH') return;
        const magnitude=Math.max(1, Math.min(10000, Math.abs(maxY)||1));
        const nextSign = maxY<0?1:-1;
        let val = nextSign<0 ? -magnitude : magnitude;
        if(val<minY){
          applyMinValue(val);
          setMinInput(displayInputValue(val,'BOTH'));
        }
        applyMaxValue(val);
        setMaxInput(displayInputValue(val,'BOTH'));
      }

      const resetMinInputDisplay = ()=> setMinInput(displayInputValue(minY));
      const resetMaxInputDisplay = ()=> setMaxInput(displayInputValue(maxY));

      useEffect(()=>{ setMinInput(displayInputValue(minY)); },[minY,era]);
      useEffect(()=>{ setMaxInput(displayInputValue(maxY)); },[maxY,era]);

      /* Era apply — with snapshots when avg-time disabled (Classic & Deduction) */
      function applyEra(newEra){
        // Save snapshot of current era before leaving, if avg-time disabled
        if(mode==="classic" && !trackClassic){
          setSavedClassicByEra(prev=>({
            ...prev,
            [era]: { date:{...date}, guesses:[...guesses], countedWrong, msg, locked, revealed }
          }));
        }
        if(mode==="deduction" && !trackDed){
          const snapshot = ded ? { ded, guesses:[...guesses], countedWrong, msg, locked, revealed } : null;
          const typeSnapshots = {...savedDedByType, [dedType]: snapshot};
          setSavedDedByEra(prev=>({
            ...prev,
            [era]: { current: snapshot, byType: typeSnapshots }
          }));
        }

        setEra(newEra);
        // Load that era's stored range (independent per era)
        let mn, mx;
        if(newEra==='AD'){ mn = adRange.min; mx = adRange.max; }
        else if(newEra==='BC'){ mn = bcRange.min; mx = bcRange.max; }
        else { mn = bothRange.min; mx = bothRange.max; }
        setMinY(mn); setMaxY(mx);

        // Classic/Deduction: preserve or generate new depending on avg-time toggle
        if(mode==="classic"){
          if(!trackClassic){
            const snap = (savedClassicByEra[newEra] || null);
            if(snap && snap.date && snap.date.y>=mn && snap.date.y<=mx){
              setDate(snap.date); setGuesses(snap.guesses||[]); setCountedWrong(!!snap.countedWrong);
              setMsg(snap.msg||""); setLocked(!!snap.locked); setRevealed(!!snap.revealed);
              return;
            }
            setMsg(""); setGuesses([]); setLocked(false); setRevealed(false); setCountedWrong(false);
            setDate(randomDate(mn,mx));
          }else{
            setMsg(""); setGuesses([]); setLocked(false); setRevealed(false); setCountedWrong(false);
            setDate(randomDate(mn,mx));
          }
        }else if(mode==="deduction"){
          const snap = savedDedByEra[newEra] || null;
          const storedByType = snap?.byType ? {...snap.byType} : blankDedTypeStore();
          setSavedDedByType(storedByType);
          if(!trackDed){
            const currentSnap = snap?.current || storedByType[dedType] || null;
            if(currentSnap && currentSnap.ded){
              setDed(currentSnap.ded); setGuesses(currentSnap.guesses||[]); setCountedWrong(!!currentSnap.countedWrong);
              setMsg(currentSnap.msg||""); setLocked(!!currentSnap.locked); setRevealed(!!currentSnap.revealed);
              return;
            }
          }
          setMsg(""); setGuesses([]); setLocked(false); setRevealed(false); setCountedWrong(false);
          spawnDedWithRange(mn,mx);
        }else{
          // Other modes: always new
          setMsg(""); setGuesses([]); setLocked(false); setRevealed(false); setCountedWrong(false);
          setDate(randomDate(mn,mx));
        }
      }

      /* visibility pause for timers */
      useEffect(()=>{
        const onVis=()=>{
          const now=performance.now();
          if(document.hidden){
            if(blitzRunning && blitzPausedAtRef.current==null) blitzPausedAtRef.current=now;
            if(qDeadlineRef.current && qPausedAtRef.current==null) qPausedAtRef.current=now;
          }else{
            if(blitzPausedAtRef.current!=null){ blitzPausedAccRef.current += now - blitzPausedAtRef.current; blitzPausedAtRef.current=null; }
            if(qPausedAtRef.current!=null){ qPausedAccRef.current += now - qPausedAtRef.current; qPausedAtRef.current=null; }
          }
        };
        document.addEventListener("visibilitychange", onVis);
        return ()=>document.removeEventListener("visibilitychange", onVis);
      },[blitzRunning]);

      /* timers + flash loop */
      useEffect(()=>{
        const needLoop = (blitzRunning || (mode==="sudden" && qDeadlineRef.current) || (mode==="flash" && active && phase==='show'));
        if(!needLoop) return;
        let raf;
        const loop=()=>{
          const now=performance.now();
          if(blitzRunning && blitzStartRef.current){
            const t=(now - blitzStartRef.current - blitzPausedAccRef.current)/1000;
            const r=Math.max(0, blitzSec - t);
            setBlitzRemain(r);
            if(r<=.001){ setBlitzRunning(false); setActive(false); setMsg("Time!"); }
          }
          if(mode==="sudden" && qDeadlineRef.current){
            const r=Math.max(0, (qDeadlineRef.current + qPausedAccRef.current - now)/1000);
            setQRemain(r);
            if(r<=.001){
              qDeadlineRef.current=null;
              updateStats(cur=>{ cur.played+=1; cur.streak=0; });
              setMsg(`Time! Answer: ${DAY[correct]}. Game over.`); setActive(false);
            }
          }
          if(mode==="flash" && active && phase==='show' && flashDeadlineRef.current){
            const rem = Math.max(0, flashDeadlineRef.current - now);
            setFlashRemainMs(rem);
          }
          raf=requestAnimationFrame(loop);
        };
        raf=requestAnimationFrame(loop);
        return ()=>cancelAnimationFrame(raf);
      },[mode,blitzSec,statsOff,blitzRunning,active,phase]);

      const trackingOn = ()=> (isTimer(mode) || (mode==="classic"&&trackClassic) || (mode==="deduction"&&trackDed));
      const avgDisabled = (statsOff || !( (mode==="classic"&&trackClassic) || (mode==="deduction"&&trackDed) || isTimer(mode) ));

      const arm=()=>{
        __hideErr();
        setActive(false); setMsg(""); setGuesses([]); setFlash(null);
        setLocked(false); setRevealed(false); setCountedWrong(false);
        setBlitzRemain(blitzSec); blitzStartRef.current=null; blitzPausedAtRef.current=null; blitzPausedAccRef.current=0; setBlitzRunning(false);
        qDeadlineRef.current=null; qPausedAtRef.current=null; qPausedAccRef.current=0; setQRemain(qSec);
        flashDeadlineRef.current=null; setFlashRemainMs(flashMs);
        tStartRef.current=null;
      };

      const begin=()=>{
        __hideErr();
        setActive(true); setMsg(""); setLocked(false); setRevealed(false); setCountedWrong(false);
        if(mode==="blitz"){ blitzStartRef.current=performance.now(); blitzPausedAccRef.current=0; blitzPausedAtRef.current=null; setBlitzRunning(true); setBlitzRemain(blitzSec); }
        if(mode==="sudden"){ const now=performance.now(); qDeadlineRef.current=now + qSec*1000; qPausedAccRef.current=0; qPausedAtRef.current=null; setQRemain(qSec); }
        if(mode==="flash"){
          setPhase('show');
          clearTimeout(flashTimerRef.current);
          const now=performance.now();
          flashDeadlineRef.current = now + flashMs;
          setFlashRemainMs(flashMs);
          flashTimerRef.current=setTimeout(()=>setPhase('hide'),Math.max(50,flashMs));
        }
        tStartRef.current=performance.now();
        pushAndNext();
      };

      function pushAndNext(){
        if(mode==="classic"||mode==="flash"||mode==="blitz"||mode==="sudden"){
          setStack(s=>[...s,{...date}]);
          const nd = randomDate(minY,maxY);
          setDate(nd);
          setGuesses([]); setRevealed(false); setLocked(false); setCountedWrong(false); setMsg("");
        }
        if(mode==="deduction"){ setDedStack(s=>[...s, ded]); spawnDed(); setMsg(""); setRevealed(false); setLocked(false); setGuesses([]); setCountedWrong(false); }
      }

      const pushLookupHistory = (entry)=>{
        setLookupHistory(prev=>{
          const next=[entry,...prev];
          return next.slice(0,20);
        });
      };

      const clearLookupHistory = ()=>setLookupHistory([]);

      useEffect(()=>{ if(mode==="classic" && trackClassic) tStartRef.current=performance.now(); },[mode,trackClassic,date]);

      /* New (never counts wrong) */
      const doNew=(opts={})=>{
        const {skipInactiveMessage=false}=opts;
        if(isTimer(mode) && !active){
          if(skipInactiveMessage){
            pushAndNext();
          }else{
            setMsg("Press Begin to start.");
          }
          return;
        }
        pushAndNext();
      };

      /* Reveal */
      function reveal(){
        if(locked) return;
        if(mode==="deduction"){
          if(!ded) return;
          if(!statsOff){ updateStats(cur=>{ cur.played+=1; cur.streak=0; }); }
          const ans = ded.type==="year" ? fmtYear(ded.y) : ded.type==="month" ? MONTH[ded.m-1] : String(ded.d);
          setMsg(`Answer: ${ans}.`); setLocked(true); setRevealed(true); setCountedWrong(true);
          return;
        }
        if(!statsOff && !countedWrong){ updateStats(cur=>{ cur.played+=1; cur.streak=0; }); }
        setCountedWrong(true);
        if(isTimer(mode)){
          setActive(false);
          if(mode==="blitz"){ setBlitzRunning(false); blitzStartRef.current=null; blitzPausedAtRef.current=null; blitzPausedAccRef.current=0; }
          if(mode==="sudden"){ qDeadlineRef.current=null; qPausedAtRef.current=null; qPausedAccRef.current=0; }
          if(mode==="flash"){ clearTimeout(flashTimerRef.current); setPhase('dash'); flashDeadlineRef.current=null; setFlashRemainMs(flashMs); }
        }
        setMsg(`Answer: ${DAY[correct]}.`); setLocked(true); setRevealed(true);
      }

      /* Back */
      function goBack(){
        if(mode==="deduction"){
          const prev = dedStack[dedStack.length-1]; if(!prev){ setMsg("Nothing to go back to."); return; }
          setDedStack(s=>s.slice(0,-1)); setDed(prev);
          const ans = prev.type==="year" ? fmtYear(prev.y) : prev.type==="month" ? MONTH[prev.m-1] : String(prev.d);
          setMsg(`Answer: ${ans}.`);
          setLocked(true); setRevealed(true); setGuesses([]); return;
        }
        const prev = stack[stack.length-1]; if(!prev){ setMsg("Nothing to go back to."); return; }
        setStack(s=>s.slice(0,-1)); setDate(prev);
        setMsg(`Answer: ${DAY[wday(prev.y,prev.m,prev.d)]}.`);
        setGuesses([]); setLocked(true); setRevealed(true);
      }

      function submitDoW(idx){
        if(isTimer(mode) && !active){ setMsg("Press Begin to start."); return; }
        if(locked) return;
        if(idx===wday(date.y,date.m,date.d)){
          setFlash({type:'good', idx}); setTimeout(()=>setFlash(null),450);
          if(!statsOff && !countedWrong && tStartRef.current && trackingOn()){ const dt=(performance.now()-tStartRef.current)/1000; updateStats(cur=>{ cur.timeSum+=dt; cur.timeCnt+=1; }); }
          if(!statsOff && !countedWrong){ updateStats(cur=>{ cur.played+=1; cur.good+=1; cur.streak+=1; if(cur.streak>cur.best) cur.best=cur.streak; }); }
          if(mode==="sudden"){
            const now=performance.now(); qDeadlineRef.current = now + qSec*1000; qPausedAccRef.current = 0; qPausedAtRef.current = null; setQRemain(qSec);
          }
          if(mode==="flash"){ clearTimeout(flashTimerRef.current); setPhase('dash'); setActive(false); flashDeadlineRef.current=null; setFlashRemainMs(flashMs); }
          pushAndNext();
        }else{
          if(mode!=="sudden"){ setGuesses(g=> g.includes(DAY[idx])?g:[...g,DAY[idx]] ); }
          if(!statsOff && !countedWrong){ updateStats(cur=>{ cur.played+=1; cur.streak=0; }); }
          setCountedWrong(true);
          if(mode==="sudden"){ setMsg(`Answer: ${DAY[correct]}. Game over.`); setActive(false); }
          setFlash({type:'bad', idx}); setTimeout(()=>setFlash(null),450);
        }
      }

      /* Deduction generation + helpers using current min/max (or provided) */
      function spawnDed(){ spawnDedWithRange(minY,maxY); }
      function spawnDedWithRange(lo,hi){
        if(dedType==="year"){
          let m=rint(1,12), d=rint(1,31), y, w;
          for(;;){ y=rint(lo,hi); if(y===0||d>dim(y,m)) continue; w=wday(y,m,d); break; }
          function neighbor(dir){ const step=dir>0?1:-1;
            for(let k=1;k<=800;k++){ let yy=y+k*step; if(yy===0) yy+=step; if(yy<lo||yy>hi) break; if(d<=dim(yy,m) && wday(yy,m,d)===w) return yy; }
            return null;
          }
          const L=neighbor(-1), U=neighbor(+1);
          let a=L==null?lo:Math.max(lo, L+1), b=U==null?hi:Math.min(hi, U-1); if(a===0) a=1; if(b===0) b=-1; if(a>b){a=b=y;}
          setDed({type:"year",m,d,w,y, a,b});
          return;
        }
        if(dedType==="month"){
          for(;;){
            let y=rint(lo,hi); if(y===0) continue;
            let d=rint(1,31); let w=rint(0,6);
            const cands=[]; for(let m=1;m<=12;m++){ if(d<=dim(y,m) && wday(y,m,d)===w) cands.push(m); }
            if(cands.length===1){ setDed({type:"month",y,d,w,m:cands[0]}); return; }
          }
        }
        if(dedType==="day"){
          let y=rint(lo,hi); if(y===0) y+= (y<0?1:-1);
          let m=rint(1,12); const D=dim(y,m);
          let d=rint(1,D); const w=wday(y,m,d);
          const bad=[]; for(let k=1;k<=D;k++){ if(k!==d && wday(y,m,k)!==w) bad.push(k); }
          const pickCount=Math.min(10, 1+bad.length);
          const picks=new Set([d]);
          while(picks.size<pickCount){ picks.add(bad[rint(0,bad.length-1)]); }
          const opts=[...picks].sort((a,b)=>a-b);
          setDed({type:"day",y,m,w,d, options:opts});
        }
      }

      const captureDedSnapshot=()=> ded ? ({
        ded,
        guesses:[...guesses],
        countedWrong,
        msg,
        locked,
        revealed
      }) : null;

      function changeDedType(nextType){
        if(nextType===dedType) return;
        if(!trackDed){
          const currentSnap=captureDedSnapshot();
          const nextSnap=savedDedByType[nextType] || null;
          pendingDedSwitchRef.current={snap:nextSnap};
          setSavedDedByType(prev=>({
            ...prev,
            [dedType]: currentSnap
          }));
        }else{
          pendingDedSwitchRef.current=null;
        }
        setDedType(nextType);
      }

      function flashDed(kind,value,ok){ setDedFlash({kind,value,ok}); setTimeout(()=>setDedFlash(null),450); }
      function submitDedAnswer(val){
        if(!ded || locked) return;
        const setCorrectThenNext = ()=>{ requestAnimationFrame(()=>setTimeout(spawnDed, 60)); setMsg(""); setGuesses([]); setCountedWrong(false); };
        const showWrong = (label)=>{ setGuesses(g=> g.includes(label)?g:[...g,label]); setCountedWrong(true); };
        if(ded.type==="year"){
          const ok = (+val)===ded.y; flashDed('year', +val, ok);
          if(ok){
            if(!statsOff && !countedWrong && trackDed && tStartRef.current){ const dt=(performance.now()-tStartRef.current)/1000; updateStats(cur=>{cur.timeSum+=dt; cur.timeCnt+=1;}); }
            if(!statsOff && !countedWrong){ updateStats(cur=>{ cur.played+=1; cur.good+=1; cur.streak+=1; if(cur.streak>cur.best) cur.best=cur.streak; }); }
            setCorrectThenNext();
          }else{
            if(!statsOff){ updateStats(cur=>{ cur.played+=1; cur.streak=0; }); }
            showWrong(fmtYear(+val));
          }
        }
        if(ded.type==="month"){
          const ok = (+val)===ded.m; flashDed('month', +val, ok);
          if(ok){
            if(!statsOff && !countedWrong && trackDed && tStartRef.current){ const dt=(performance.now()-tStartRef.current)/1000; updateStats(cur=>{cur.timeSum+=dt; cur.timeCnt+=1;}); }
            if(!statsOff && !countedWrong){ updateStats(cur=>{ cur.played+=1; cur.good+=1; cur.streak+=1; if(cur.streak>cur.best) cur.best=cur.streak; }); }
            setCorrectThenNext();
          }else{
            if(!statsOff){ updateStats(cur=>{ cur.played+=1; cur.streak=0; }); }
            showWrong(MONTH[+val-1]);
          }
        }
        if(ded.type==="day"){
          const ok = (+val)===ded.d; flashDed('day', +val, ok);
          if(ok){
            if(!statsOff && !countedWrong && trackDed && tStartRef.current){ const dt=(performance.now()-tStartRef.current)/1000; updateStats(cur=>{cur.timeSum+=dt; cur.timeCnt+=1;}); }
            if(!statsOff && !countedWrong){ updateStats(cur=>{ cur.played+=1; cur.good+=1; cur.streak+=1; if(cur.streak>cur.best) cur.best=cur.streak; }); }
            setCorrectThenNext();
          }else{
            if(!statsOff){ updateStats(cur=>{ cur.played+=1; cur.streak=0; }); }
            showWrong(String(+val));
          }
        }
      }

      /* mode changes */
      useEffect(()=>{ arm(); setGuesses([]); setStack([]); setDedStack([]); setMsg(""); setLocked(false); setRevealed(false);
        if(mode==="deduction"){ setPhase('dash'); pendingDedSwitchRef.current=null; setSavedDedByType(blankDedTypeStore()); setDed(null); }
      },[mode]);

      useEffect(()=>{
        if(mode!=="deduction") return;
        setDedFlash(null);
        const pending=pendingDedSwitchRef.current;
        pendingDedSwitchRef.current=null;
        if(!trackDed){
          const snap=pending?.snap || savedDedByType[dedType] || null;
          if(snap && snap.ded){
            setDed(snap.ded);
            setGuesses(snap.guesses||[]);
            setCountedWrong(!!snap.countedWrong);
            setMsg(snap.msg||"");
            setLocked(!!snap.locked);
            setRevealed(!!snap.revealed);
            return;
          }
        }
        setMsg("");
        setGuesses([]);
        setLocked(false);
        setRevealed(false);
        setCountedWrong(false);
        spawnDed();
      },[dedType, mode, trackDed, savedDedByType]);

      /* slider handlers — each era updates its own store only */
      const showDash = isTimer(mode) && !active;
      const showDots = (mode==="flash" && active && phase==='hide');

      const dedHeadline = ded ? (ded.type==="year" ? `${MONTH[ded.m-1]} ${ded.d}` : ded.type==="month" ? `${ded.d}, ${fmtYear(ded.y)}` : `${MONTH[ded.m-1]}, ${fmtYear(ded.y)}`) : "—";
      const headline = mode==="deduction" ? dedHeadline : (showDash ? "—" : showDots ? "…" : fmt(date.y,date.m,date.d));

      const baseBtn="w-full rounded-2xl border px-4 py-3 text-base md:text-sm transition shadow-sm select-none";
      const idleBtn="border-purple-800/60 bg-purple-900/30 hover:bg-purple-900/60";
      const optionsDisabled = ( (isTimer(mode) && !active) || locked );

      /* range panel */
      const [rangeOpen,setRangeOpen]=useState(false);
      const [rangeMaxHeight,setRangeMaxHeight]=useState('0px');
      const rangeContentRef=useRef(null);

      useEffect(()=>{
        const inner=rangeContentRef.current;
        if(!inner) return;
        if(rangeOpen){
          setRangeMaxHeight(`${inner.scrollHeight + 24}px`);
        }else{
          setRangeMaxHeight('0px');
        }
      },[rangeOpen, era, minInput, maxInput, minY, maxY]);

      useEffect(()=>{
        if(!rangeOpen) return;
        const onResize=()=>{
          const inner=rangeContentRef.current;
          if(inner){
            setRangeMaxHeight(`${inner.scrollHeight + 24}px`);
          }
        };
        window.addEventListener('resize', onResize);
        return ()=>window.removeEventListener('resize', onResize);
      },[rangeOpen]);
      const RangePanel = (
        <div className="mt-3 rounded-2xl card p-3">
          <button type="button" onClick={()=>setRangeOpen(o=>!o)} aria-expanded={rangeOpen}
                  className="w-full text-left text-sm text-purple-200/90 flex items-center justify-between">
            <span>Year range <span className="tabular-nums ml-1">{fmtRangeYear(minY)} → {fmtRangeYear(maxY)}</span></span>
            <span className={`text-white/90 text-[7px] leading-none transition-transform ease-in-out ${rangeOpen?'rotate-180':''}`}
                  style={{transitionDuration:'350ms'}}>▼</span>
          </button>
          <div className="expander" style={{maxHeight:rangeMaxHeight}}>
            <div ref={rangeContentRef} className="mt-3 space-y-4 pr-1">
              <div className="grid grid-cols-2 gap-3">
                <div>
                  <label htmlFor={minInputId} className="block text-xs text-purple-200/80 mb-1">Start year</label>
                  <div className="relative">
                    <input
                      id={minInputId}
                      type="text"
                      inputMode="numeric"
                      pattern="[0-9]*"
                      value={minInput}
                      onChange={e=>handleMinInputChange(e.target.value)}
                      onBlur={resetMinInputDisplay}
                      onKeyDown={blockMinusKey}
                      onBeforeInput={blockMinusBeforeInput}
                      className="w-full panel rounded-xl px-3 py-2 pr-11 focus:outline-none focus:ring-2 focus:ring-purple-400 tabular-nums"
                    />
                    <button
                      type="button"
                      onClick={()=>toggleMinSign()}
                      tabIndex={era==='BOTH'?0:-1}
                      className={`absolute right-3 top-1/2 -translate-y-1/2 text-[11px] font-semibold uppercase text-purple-200/80 focus:outline-none transition-colors ${era==='BOTH'?'cursor-pointer hover:text-purple-100':'pointer-events-none'}`}
                      aria-label={era==='BOTH'?`Toggle start year between AD and BC (currently ${labelForYear(minY)})`:undefined}
                    >
                      {labelForYear(minY)}
                    </button>
                  </div>
                </div>
                <div>
                  <label htmlFor={maxInputId} className="block text-xs text-purple-200/80 mb-1">End year</label>
                  <div className="relative">
                    <input
                      id={maxInputId}
                      type="text"
                      inputMode="numeric"
                      pattern="[0-9]*"
                      value={maxInput}
                      onChange={e=>handleMaxInputChange(e.target.value)}
                      onBlur={resetMaxInputDisplay}
                      onKeyDown={blockMinusKey}
                      onBeforeInput={blockMinusBeforeInput}
                      className="w-full panel rounded-xl px-3 py-2 pr-11 focus:outline-none focus:ring-2 focus:ring-purple-400 tabular-nums"
                    />
                    <button
                      type="button"
                      onClick={()=>toggleMaxSign()}
                      tabIndex={era==='BOTH'?0:-1}
                      className={`absolute right-3 top-1/2 -translate-y-1/2 text-[11px] font-semibold uppercase text-purple-200/80 focus:outline-none transition-colors ${era==='BOTH'?'cursor-pointer hover:text-purple-100':'pointer-events-none'}`}
                      aria-label={era==='BOTH'?`Toggle end year between AD and BC (currently ${labelForYear(maxY)})`:undefined}
                    >
                      {labelForYear(maxY)}
                    </button>
                  </div>
                </div>
              </div>
              <p className="text-xs text-purple-300/70">Proleptic Gregorian calendar. Year 0 isn’t available—use 1 BC or 1 AD. Each era remembers its own range.</p>
            </div>
          </div>
        </div>
      );

      const showSuddenBar = mode==="sudden";
      const suddenSeconds = (active && qDeadlineRef.current) ? qRemain : (qRemain<=0.05 ? 0 : qSec);
      const suddenTimeLabel = formatSecondsLabel(suddenSeconds);
      const suddenPercent = (active && qDeadlineRef.current && qSec>0) ? Math.max(0, Math.min(100,(qRemain/qSec)*100)) : 100;
      const showFlashBar = mode==="flash";
      const flashSeconds = (active && phase==='show') ? (flashRemainMs/1000) : ((flashRemainMs/1000)<=0.05 ? 0 : (flashMs/1000));
      const flashTimeLabel = formatSecondsLabel(flashSeconds);
      const flashPercent = (active && phase==='show' && flashDeadlineRef.current && flashMs>0) ? Math.max(0, Math.min(100,(flashRemainMs/flashMs)*100)) : 100;
      const timerBusy = isTimer(mode) && active;

      /* should reset stats create a new date? */
      function shouldNewOnReset(){
        const avgEnabled = (mode==="classic"?trackClassic : mode==="deduction"?trackDed : true);
        if(!avgEnabled && !countedWrong) return false;
        return true;
      }

      /* Avg toggle click handler (disable/enable) */
      function toggleAvg(disable){
        if(mode!=="classic" && mode!=="deduction") return;
        if(disable){ // turning OFF tracking
          if(mode==="classic") setTrackClassic(false); else setTrackDed(false);
          tStartRef.current=null;
        }else{       // turning ON tracking -> acts like New (no penalty)
          if(mode==="classic") setTrackClassic(true); else setTrackDed(true);
          doNew();
          tStartRef.current=performance.now();
        }
      }

      return (
        <div className="mx-auto px-4 py-5 w-full max-w-[480px] md:max-w-3xl lg:max-w-4xl">
          {/* Header */}
          <div className="flex items-center justify-between gap-4">
            <h1 className="text-xl md:text-2xl font-semibold leading-none">Calendar Game</h1>
            <div className="relative">
              <select
                ref={modeSelectRef}
                value={mode}
                onChange={e=>{ __hideErr(); const nextMode=e.target.value; setMode(nextMode); e.target.blur(); modeSelectRef.current?.blur(); }}
                className="panel rounded-xl px-2.5 py-2 pr-9 text-sm focus:outline-none focus:ring-2 focus:ring-purple-400 appearance-none"
              >
                <option value="classic">Classic</option>
                <option value="blitz">Blitz</option>
                <option value="sudden">Sudden Death</option>
                <option value="flash">Flash</option>
                <option value="deduction">Deduction</option>
                <option value="lookup">Lookup</option>
                <option value="method">Method</option>
              </select>
              <div className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 flex flex-col items-center leading-none text-[7px] text-white/90">
                <span>▲</span><span>▼</span>
              </div>
            </div>
          </div>

          {/* Stats/toggles (not on lookup/method) */}
          {mode!=="lookup" && mode!=="method" && (
            <>
              <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-3">
                <Stat label="Score" value={`${S.good}/${S.played}`} disabled={statsOff}/>
                <Stat label="Accuracy" value={`${S.played?(S.good/S.played*100).toFixed(1):"0.0"}%`} disabled={statsOff}/>
                <StatTwo label="Streak / Longest" left={S.streak} right={S.best} disabled={statsOff}/>
                <Stat label="Avg time (correct)" value={(S.timeCnt?`${(S.timeSum/S.timeCnt).toFixed(2)}s`:"—")} disabled={avgDisabled}/>
              </div>
              <div className="mt-2 flex flex-wrap items-center justify-between gap-3">
                <div className="flex flex-wrap items-center gap-3 w-full">
                  {/* Era segmented */}
                  <div className="flex rounded-xl overflow-hidden border border-purple-800/60">
                    {[{k:'AD',label:'AD'},{k:'BOTH',label:'AD+BC'},{k:'BC',label:'BC'}].map(seg=>(
                      <button key={seg.k} type="button"
                        onClick={()=>{ if(era!==seg.k) applyEra(seg.k); }}
                        className={`px-3 py-1.5 text-sm ${era===seg.k ? 'bg-purple-600' : 'bg-purple-900/40 hover:bg-purple-900/70'} ${seg.k!=='BC'?'border-r border-purple-800/60':''}`}>
                        {seg.label}
                      </button>
                    ))}
                  </div>

                  {mode==="blitz" && (
                    <div className="flex items-center gap-2 ml-auto flex-1 min-w-[150px] justify-end">
                      <span className="text-xs text-purple-300/80">Duration:</span>
                      <input type="range" min="15" max="180" step="5" value={blitzSec}
                            onChange={e=>{const v=+e.target.value; setBlitzSec(v); if(!active) setBlitzRemain(v);}} className="accent-purple-500 w-28 sm:w-32"/>
                      <span className="tabular-nums text-xs w-10 text-right">{blitzSec}s</span>
                    </div>
                  )}
                  {mode==="sudden" && (
                    <div className="flex items-center gap-2">
                      <span className="text-xs text-purple-300/80">Per Q:</span>
                      <input type="range" min="3" max="20" step="1" value={qSec}
                            onChange={e=>{const v=+e.target.value; setQSec(v); if(!active) setQRemain(v);}} className="accent-purple-500"/>
                      <span className="tabular-nums text-xs w-10 text-right">{qSec}s</span>
                    </div>
                  )}
                  {mode==="flash" && (
                    <div className="flex items-center gap-2 ml-auto flex-1 min-w-[150px] justify-end">
                      <span className="text-xs text-purple-300/80">Show:</span>
                      <input type="range" min="100" max="3000" step="50" value={flashMs}
                            onChange={e=>setFlashMs(+e.target.value)} className="accent-purple-500 w-28 sm:w-32"/>
                      <span className="tabular-nums text-xs w-12 text-right">{flashMs}ms</span>
                    </div>
                  )}

                  {(mode==="classic"||mode==="deduction") && (
                    <label className="flex items-center gap-2 text-sm">
                      <input type="checkbox" className="sr-only"
                        checked={!(mode==="classic"?trackClassic:trackDed)}
                        onChange={e=> toggleAvg(e.target.checked)} />
                      <span className={`w-10 h-6 rounded-full relative ${(!(mode==="classic"?trackClassic:trackDed))?"bg-rose-500/70":"bg-zinc-600"}`}>
                        <span className={`absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white transition-transform ${(!(mode==="classic"?trackClassic:trackDed))?"translate-x-4":""}`}></span>
                      </span>
                      <span>Disable avg time</span>
                    </label>
                  )}
                </div>
                <div className="flex items-center gap-3">
                  <label className="flex items-center gap-2 text-sm">
                    <input type="checkbox" className="sr-only" checked={statsOff} onChange={e=>setStatsOff(e.target.checked)} />
                    <span className={`w-10 h-6 rounded-full relative ${statsOff?"bg-rose-500/70":"bg-zinc-600"}`}>
                      <span className={`absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white transition-transform ${statsOff?"translate-x-4":""}`}></span>
                    </span>
                    <span>Disable stats</span>
                  </label>
                  <button type="button" className="text-xs px-3 py-1.5 rounded-lg bg-purple-700 hover:bg-purple-600"
                          onClick={()=>{
                            const needNew = (()=>{
                              const avgEnabled = (mode==="classic"?trackClassic : mode==="deduction"?trackDed : true);
                              if(!avgEnabled && !countedWrong) return false;
                              return true;
                            })();
                            resetStatsCurrent();
                            if(needNew) doNew({skipInactiveMessage:true});
                          }}>Reset stats</button>
                </div>
              </div>
            </>
          )}

          {/* Year range (not on lookup/method) */}
          {mode!=="lookup" && mode!=="method" && RangePanel}

          {/* MAIN CARD */}
          <div className="mt-5 p-5 rounded-3xl card">
            {/* Blitz/Sudden/Flash bars */}
            {mode==="blitz" && (
              <div className="mb-3">
                <div className="flex items-center justify-between text-xs text-purple-200/80 mb-1"><div>Blitz</div><div className="tabular-nums">{formatSecondsLabel(blitzRemain)}</div></div>
                <div className="bar"><span style={{width:`${Math.max(0,Math.min(100,(blitzRemain/blitzSec)*100))}%`}}></span></div>
              </div>
            )}
            {showSuddenBar && (
              <div className="mb-3">
                <div className="flex items-center justify-between text-xs text-purple-200/80 mb-1"><div>Per-question</div><div className="tabular-nums">{suddenTimeLabel}</div></div>
                <div className="bar"><span style={{width:`${suddenPercent}%`}}></span></div>
              </div>
            )}
            {showFlashBar && (
              <div className="mb-3">
                <div className="flex items-center justify-between text-xs text-purple-200/80 mb-1"><div>Flash</div><div className="tabular-nums">{flashTimeLabel}</div></div>
                <div className="bar"><span style={{width:`${flashPercent}%`}}></span></div>
              </div>
            )}

            {/* Method page (blank for now) */}
            {mode==="method" && <div className="min-h-[40vh]"></div>}

            {/* Headline */}
            {mode!=="lookup" && mode!=="deduction" && mode!=="method" && (
              <div className="text-center">
                <div className="text-xs uppercase tracking-widest text-purple-100/80">What day is this?</div>
                <div className="mt-1 text-3xl md:text-4xl font-bold">{(isTimer(mode)&&!active)?"—": (mode==="flash"&&active&&phase==='hide')?"…": fmt(date.y,date.m,date.d)}</div>
              </div>
            )}
            {mode==="deduction" && (
              <div className="text-center">
                <div className="text-xs uppercase tracking-widest text-purple-100/80">
                  {dedType==="year"?"What year is this?":dedType==="month"?"What month is this?":"What day is this?"}
                </div>
                <div className="mt-1 text-3xl md:text-4xl font-bold">{ded ? (ded.type==="year"?`${MONTH[ded.m-1]} ${ded.d}`: ded.type==="month"?`${ded.d}, ${fmtYear(ded.y)}` : `${MONTH[ded.m-1]}, ${fmtYear(ded.y)}`) : "—"}</div>
                {ded && <div className="mt-1 text-lg md:text-xl text-purple-100">Weekday:&nbsp;<span className="font-semibold text-xl">{DAY[ded.w]}</span></div>}
              </div>
            )}

            {/* ======= CLASSIC / BLITZ / SUDDEN / FLASH ======= */}
            {["classic","blitz","sudden","flash"].includes(mode) && (
              <>
                <div className={`mt-4 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-7 gap-3 ${((isTimer(mode)&&!active)||locked)?'opacity-60 pointer-events-none':''}`}>
                  {DAY.map((n,i)=>(
                    <button key={n} type="button"
                      onClick={()=>{ submitDoW(i); setInput(""); if(isTouch) document.activeElement?.blur(); }}
                      className={`${baseBtn} ${flash && flash.idx===i ? (flash.type==='good'?'flash-good':'flash-bad')+' border-transparent' : idleBtn}`}>{n}</button>
                  ))}
                </div>

                {/* Action bubble */}
                <div className="mt-4 rounded-2xl panel p-3">
                  <div className="flex flex-wrap items-center gap-2">
                    {isTimer(mode) && (!active
                      ? <button type="button" className="px-4 py-2 rounded-xl bg-purple-600 text-white text-sm font-medium" onClick={()=>begin()}>Begin</button>
                      : <button type="button" className="px-4 py-2 rounded-xl bg-rose-600/90 text-white text-sm font-medium" onClick={()=>arm()}>Reset</button>
                    )}
                    <button
                      type="button"
                      className={`px-3 py-2 rounded-xl border border-purple-700/60 bg-purple-900/50 text-sm ${timerBusy?'opacity-60 pointer-events-none':''}`}
                      onClick={()=>doNew()}
                    >New</button>
                    <button type="button" className={`px-3 py-2 rounded-xl border border-purple-700/60 bg-purple-900/50 text-sm ${locked?'opacity-60 pointer-events-none':''}`} onClick={()=>reveal()}>Reveal</button>
                    <button
                      type="button"
                      className={`px-3 py-2 rounded-xl border border-purple-700/60 bg-purple-900/50 text-sm ${timerBusy?'opacity-60 pointer-events-none':''}`}
                      onClick={()=>goBack()}
                    >Back</button>
                  </div>

                  {(msg || (guesses.length>0 && mode!=="sudden")) && (
                    <div className="mt-3 text-purple-100/90 text-sm">
                      {msg && <div>{msg}</div>}
                      {(mode!=="sudden" && guesses.length>0) && (<div className="mt-2 flex flex-wrap gap-1 items-center"><span className="text-purple-300/80 text-xs mr-1">Guesses so far:</span>{guesses.map(g=><span key={g} className="chip">{g}</span>)}</div>)}
                    </div>
                  )}
                </div>
              </>
            )}

            {/* ======= DEDUCTION ======= */}
            {mode==="deduction" && (
              <>
                <div className="mt-3 flex flex-wrap gap-2 justify-center">
                  {["year","month","day"].map(t=>(
                    <button key={t} type="button" onClick={()=>changeDedType(t)}
                      className={`px-3 py-1.5 rounded-lg text-sm border ${dedType===t?'bg-purple-600 border-purple-500':'bg-purple-900/40 border-purple-800/60 hover:bg-purple-900/70'}`}>
                      {t[0].toUpperCase()+t.slice(1)}
                    </button>
                  ))}
                </div>

                <div className={`mt-4 ${locked?'opacity-60 pointer-events-none':''}`}>
                  {ded && ded.type==="year" && (
                    <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2">
                      {Array.from({length: ded.b - ded.a + 1}, (_,i)=>ded.a+i).map(y=>(
                        <button key={y} type="button" onClick={()=>submitDedAnswer(y)}
                          className={`${baseBtn} ${idleBtn} py-2 text-sm ${dedFlash&&dedFlash.kind==='year'&&dedFlash.value===y ? (dedFlash.ok?'flash-good':'flash-bad')+' border-transparent':''}`}>{fmtYear(y)}</button>
                      ))}
                    </div>
                  )}
                  {ded && ded.type==="month" && (
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                      {MONTH.map((m,i)=>(
                        <button key={m} type="button" onClick={()=>submitDedAnswer(i+1)}
                          className={`${baseBtn} ${idleBtn} ${dedFlash&&dedFlash.kind==='month'&&dedFlash.value===i+1 ? (dedFlash.ok?'flash-good':'flash-bad')+' border-transparent':''}`}>{m}</button>
                      ))}
                    </div>
                  )}
                  {ded && ded.type==="day" && (
                    <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2">
                      {ded.options.map(dv=>(
                        <button key={dv} type="button" onClick={()=>submitDedAnswer(dv)}
                          className={`${baseBtn} ${idleBtn} ${dedFlash&&dedFlash.kind==='day'&&dedFlash.value===dv ? (dedFlash.ok?'flash-good':'flash-bad')+' border-transparent':''}`}>{dv}</button>
                      ))}
                    </div>
                  )}
                </div>

                <div className="mt-4 rounded-2xl panel p-3">
                  <div className="flex flex-wrap gap-2">
                    <button type="button" className="px-3 py-2 rounded-xl border border-purple-700/60 bg-purple-900/50 text-sm" onClick={()=>{ setDedStack(s=>[...s,ded]); spawnDed(); setMsg(""); setLocked(false); setRevealed(false); setGuesses([]); setCountedWrong(false); }}>New</button>
                    <button type="button" className={`px-3 py-2 rounded-xl border border-purple-700/60 bg-purple-900/50 text-sm ${locked?'opacity-60 pointer-events-none':''}`} onClick={()=>reveal()}>Reveal</button>
                    <button type="button" className="px-3 py-2 rounded-xl border border-purple-700/60 bg-purple-900/50 text-sm" onClick={()=>goBack()}>Back</button>
                  </div>
                  {(msg || guesses.length>0) && (
                    <div className="mt-3 text-sm">
                      {msg && <div>{msg}</div>}
                      {guesses.length>0 && (<div className="mt-2 flex flex-wrap gap-1 items-center"><span className="text-purple-300/80 text-xs mr-1">Guesses so far:</span>{guesses.map(g=><span key={g} className="chip">{g}</span>)}</div>)}
                    </div>
                  )}
                </div>
              </>
            )}

            {/* ======= LOOKUP ======= */}
            {mode==="lookup" && <LookupCard history={lookupHistory} onAddHistory={pushLookupHistory} onClearHistory={clearLookupHistory} />}
          </div>
        </div>
      );
    }

    /* --------- Lookup component --------- */
    function LookupCard({history=[], onAddHistory, onClearHistory}){
      const [lookupIn,setLookupIn]=React.useState("");
      const [lookupOut,setLookupOut]=React.useState("");
      function isLeapY(y){ y = y>0?y:1-Math.abs(y); return y%400===0 || (y%4===0 && y%100!==0); }
      function dimY(y,m){ return m===2 ? (isLeapY(y)?29:28) : [4,6,9,11].includes(m)?30:31; }
      function wdayY(y,m,d){ function jdn(y,m,d){ const a=Math.floor((14-m)/12),y2=y+4800-a,m2=m-3+12*a; return d+Math.floor((153*m2+2)/5)+365*y2+Math.floor(y2/4)-Math.floor(y2/100)+Math.floor(y2/400)-32045; } const toA = y=>y>0?y:1-Math.abs(y); return (jdn(toA(y),m,d)+1)%7; }
      const MONTH=["January","February","March","April","May","June","July","August","September","October","November","December"];
      const DAY=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
      const fmtYear = y => y>0?String(y):`${Math.abs(y)} BC`;
      function runLookup(){
        const s=lookupIn.trim();
        const m = /^(-?\d{1,2})\/(\d{1,2})\/(-?\d{1,5})$/.exec(s);
        if(!m){ setLookupOut("Enter date in month/day/year format, e.g., 7/4/1776. Years allowed −10000…10000 (no year 0)."); return; }
        let mm=+m[1], dd=+m[2], yy=+m[3];
        if(yy===0){ setLookupOut("There is no year 0. Use −1 for 1 BC."); return; }
        if(yy<-10000 || yy>10000){ setLookupOut("Year must be between −10000 and 10000."); return; }
        if(mm<1||mm>12){ setLookupOut("Month must be 1–12."); return; }
        const maxd=dimY(yy,mm);
        if(dd<1||dd>maxd){ setLookupOut(`Day must be 1–${maxd} for ${MONTH[mm-1]}.`); return; }
        const d=DAY[wdayY(yy,mm,dd)];
        const resultText = `${MONTH[mm-1]} ${dd}, ${fmtYear(yy)} is a ${d}.`;
        setLookupOut(resultText);
        if(onAddHistory){
          const entry={
            id:`${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`,
            query:`${mm}/${dd}/${yy}`,
            label:`${MONTH[mm-1]} ${dd}, ${fmtYear(yy)}`,
            weekday:d,
            result:resultText
          };
          onAddHistory(entry);
        }
      }
      function clearLookup(){ setLookupIn(""); if(document.activeElement) document.activeElement.blur(); setLookupOut(""); }
      const entries = Array.isArray(history)?history:[];
      const handleHistorySelect = (entry)=>{
        setLookupIn(entry?.query||"");
        setLookupOut(entry?.result||"");
        if(document.activeElement) document.activeElement.blur();
      };
      const handleClearHistory = ()=>{ if(onClearHistory) onClearHistory(); };
      return (
        <div className="mt-1 rounded-2xl panel p-4">
          <div className="flex items-stretch gap-2">
            <input value={lookupIn} onChange={e=>setLookupIn(e.target.value)} placeholder="e.g., 7/4/1776"
                  className="panel rounded-xl px-3 py-2 focus:outline-none focus:ring-2 focus:ring-purple-400 flex-1 min-w-0"/>
            <button type="button" onClick={()=>runLookup()} className="px-4 py-2 rounded-xl bg-purple-600 text-white text-sm font-medium">Lookup</button>
            <button type="button" onClick={()=>clearLookup()} className="px-4 py-2 rounded-xl bg-zinc-700 text-white text-sm font-medium">Clear</button>
          </div>
          {lookupOut && <div className="mt-3 text-sm">{lookupOut}</div>}
          <ul className="mt-4 text-xs text-purple-100/90 space-y-2 list-disc list-inside">
            <li>Format: <b>month/day/year</b> (e.g., <b>7/4/1776</b>).</li>
            <li>BC years: use a leading minus (e.g., <b>-1</b> = <b>1 BC</b>). No year 0.</li>
            <li>Valid range: <b>−10000…10000</b>. Days must be valid for the month.</li>
          </ul>
          {entries.length>0 && (
            <div className="mt-5 pt-4 border-t border-purple-500/40">
              <div className="flex items-center justify-between text-[11px] uppercase tracking-wide text-purple-200/70">
                <span>History</span>
                <button type="button" onClick={()=>handleClearHistory()} className="text-purple-200/70 font-medium">Clear history</button>
              </div>
              <ul className="mt-3 space-y-2">
                {entries.map(entry=>(
                  <li key={entry.id}>
                    <button type="button" onClick={()=>handleHistorySelect(entry)}
                            className="w-full text-left px-3 py-2 rounded-xl panel flex items-center justify-between gap-3 text-xs">
                      <span className="block text-[13px] font-medium text-purple-100/90">{entry.label}</span>
                      <span className="text-[12px] font-semibold text-purple-200/80">{entry.weekday}</span>
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>
